<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Claude Verbs -- Themed spinner verbs for Claude Code</title>
  <meta name="description" content="Replace boring spinner text with themed verb sets. Install in seconds.">
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0d1117;
      overflow: hidden;
      height: 100vh;
    }

    /* ---- PixiJS background ---- */
    #canvas-wrap {
      position: fixed;
      inset: -8vmax;
      z-index: 0;
      transform: perspective(1200px) rotateX(4deg) rotateY(-3deg);
      transform-origin: center center;
    }

    #canvas-wrap canvas {
      display: block;
      width: 100% !important;
      height: 100% !important;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    /* ---- Dead pixels ---- */
    .dead-pixel {
      position: absolute;
      width: 3px;
      height: 3px;
      background: #0a0c10;
      z-index: 1;
      pointer-events: none;
    }

    /* ---- CSS Glare overlay ---- */
    #glare-overlay {
      position: absolute;
      top: -10%;
      right: -10%;
      width: 60vmax;
      height: 40vmax;
      background: radial-gradient(ellipse at center, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.02) 40%, rgba(255,255,255,0) 70%);
      mix-blend-mode: screen;
      pointer-events: none;
      z-index: 2;
    }

  </style>
</head>
<body>
  <!--SETS_DATA-->

  <div id="canvas-wrap">
    <div class="dead-pixel" id="dead-pixel-1"></div>
    <div class="dead-pixel" id="dead-pixel-2"></div>
    <div id="glare-overlay"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.4.2/dist/pixi.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@pixi/filter-advanced-bloom@5.2.1/dist/filter-advanced-bloom.min.js"></script>
  <script>
  (function () {
    'use strict';

    /* ---- Constants ---- */

    var SPINNER_FRAMES = ['\u00b7', '\u273b', '\u273d', '\u2736', '\u2733', '\u2722'];
    var SPINNER_TIMELINE = [0, 0, 1, 2, 3, 4, 5, 5];
    var FRAME_MS = 90;
    var VERB_MS = 2200;
    var TOKEN_RATE = 40;

    var COLOR_VERB = 0xd78787;
    var COLOR_ELLIPSIS = 0xffaf87;
    var COLOR_META = 0x555555;
    var BG_COLOR = 0x0d1117;

    var FONT_MAIN = 56;
    var FONT_META = FONT_MAIN;
    var FONT_FAMILY = '"SF Mono", "Fira Code", "Cascadia Code", monospace';
    var SCROLL_MS = 350;
    var DEMO_TIMEOUT_MS = 15000;

    /* ---- Helpers ---- */

    function shuffle(arr) {
      var a = arr.slice();
      for (var i = a.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var t = a[i]; a[i] = a[j]; a[j] = t;
      }
      return a;
    }

    function getAllVerbs(sets) {
      var all = [];
      var keys = Object.keys(sets);
      for (var k = 0; k < keys.length; k++) {
        var group = sets[keys[k]];
        for (var g = 0; g < group.length; g++) {
          if (group[g].verbs) all = all.concat(group[g].verbs);
        }
      }
      return all;
    }

    function fmtElapsed(ms) {
      var s = Math.floor(ms / 1000);
      if (s < 60) return s + 's';
      return Math.floor(s / 60) + 'm ' + (s % 60) + 's';
    }

    function repeat(ch, n) {
      var s = '';
      for (var i = 0; i < n; i++) s += ch;
      return s;
    }

    function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
    function randInt(lo, hi) { return lo + Math.floor(Math.random() * (hi - lo + 1)); }

    /* Called at init; references sets + colour constants defined below */
    function buildHeaderRows(cols) {
      var n = 0;
      var ks = Object.keys(sets);
      for (var ki = 0; ki < ks.length; ki++) n += sets[ks[ki]].length;

      var inner = cols - 2;
      var lw = 38;
      var rw = inner - lw - 1;

      function ctr(s, w) {
        var g = Math.max(0, w - s.length);
        var l = Math.floor(g / 2);
        return repeat(' ', l) + s + repeat(' ', g - l);
      }
      function rpad(s, w) { return s + repeat(' ', Math.max(0, w - s.length)); }

      function row(left, right, c) {
        return { parts: [
          { text: '\u2502', color: C_BORDER },
          { text: ctr(left, lw), color: c },
          { text: '\u2502', color: C_BORDER },
          { text: rpad(' ' + right, rw), color: c },
          { text: '\u2502', color: C_BORDER },
        ] };
      }

      var title = ' Claude Verbs ';
      var dashes = inner - title.length;
      var dl = Math.floor(dashes / 2);

      return [
        { parts: [
          { text: '\u256d' + repeat('\u2500', dl), color: C_BORDER },
          { text: title, color: C_ACCENT },
          { text: repeat('\u2500', dashes - dl) + '\u256e', color: C_BORDER },
        ] },
        row('', '', C_BORDER),
        row('Welcome!', 'Getting started', COLOR_VERB),
        row('', 'spinner-verbs install <name>', C_DIM),
        row('\u2590\u259b\u2588\u2588\u2588\u259c\u258c', repeat('\u2500', 25), COLOR_VERB),
        row('\u259d\u259c\u2588\u2588\u2588\u2588\u2588\u259b\u2598', n + ' verb sets available', COLOR_VERB),
        row('\u2598\u2598 \u259d\u259d', 'Arrow keys to browse', C_DIM),
        row('', '', C_BORDER),
        row('spinner-verbs v0.1', '', COLOR_VERB),
        row('', '', C_BORDER),
        { parts: [{ text: '\u2570' + repeat('\u2500', inner) + '\u256f', color: C_BORDER }] },
        { parts: [{ text: ctr('Claude Verbs \u2014 themed spinner verbs for Claude Code', cols), color: COLOR_META }] },
      ];
    }

    /* ---- Sets + locale ---- */

    var sets = (typeof SETS !== 'undefined') ? SETS : {};

    function detectLocale() {
      var lang = (navigator.language || 'en').slice(0, 2).toLowerCase();
      if (sets[lang]) return lang;
      return sets['en'] ? 'en' : Object.keys(sets)[0] || 'en';
    }

    var locale = detectLocale();

    var idiotSet = null;
    if (sets['en']) {
      for (var si = 0; si < sets['en'].length; si++) {
        if (sets['en'][si].name === 'idiot') { idiotSet = sets['en'][si]; break; }
      }
    }

    /* build browse list: locale sets first, padded with random others if < 3 */
    var localeSets = (sets[locale] || []).slice();
    if (localeSets[0] === idiotSet && localeSets.length > 1) localeSets.push(localeSets.shift());
    else if (localeSets[0] === idiotSet) localeSets = [];
    if (localeSets.length < 3) {
      var pool = [];
      var lkeys = Object.keys(sets);
      for (var lk = 0; lk < lkeys.length; lk++) {
        for (var gi = 0; gi < sets[lkeys[lk]].length; gi++) {
          var ps = sets[lkeys[lk]][gi];
          if (ps !== idiotSet && localeSets.indexOf(ps) === -1) pool.push(ps);
        }
      }
      pool = shuffle(pool);
      while (localeSets.length < 3 && pool.length > 0) localeSets.push(pool.shift());
    }
    var defaultSet = localeSets[0] || null;

    /* ---- State Machine ---- */

    var S = { IDLE: 0, BROWSING: 1, DEMO: 2, POST_DEMO: 3, BUGGED: 4 };

    var machine = {
      current: S.IDLE,
      previous: S.IDLE,
      activeSet: null,
      browseIndex: 0,
      skipCount: 0,
      postIndex: 0,
      demoTimer: null,
    };

    var POST_SUGGESTIONS = [
      { text: 'copy command to get access to spinner verb cli', action: 'copy' },
      { text: 'show marketplace', action: 'marketplace' },
    ];

    /* ---- PixiJS setup ---- */

    PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;
    PIXI.settings.ROUND_PIXELS = true;

    var wrap = document.getElementById('canvas-wrap');

    /* ---- Dead pixel placement (seeded pseudo-random) ---- */
    var seed = 42;
    function seededRand() { seed = (seed * 16807 + 0) % 2147483647; return seed / 2147483647; }
    var dp1 = document.getElementById('dead-pixel-1');
    var dp2 = document.getElementById('dead-pixel-2');
    dp1.style.left = (15 + seededRand() * 70) + '%';
    dp1.style.top = (10 + seededRand() * 60) + '%';
    dp2.style.left = (15 + seededRand() * 70) + '%';
    dp2.style.top = (10 + seededRand() * 60) + '%';
    dp2.style.background = '#12151c';

    var app = new PIXI.Application({
      resizeTo: wrap,
      resolution: window.devicePixelRatio * 0.125,
      autoDensity: true,
      backgroundColor: BG_COLOR,
      antialias: false,
    });
    wrap.appendChild(app.view);

    /* ---- LCD subpixel overlay (enabled by default) ---- */

    var lcdOverlay = document.createElement('div');
    lcdOverlay.id = 'lcd-overlay';
    lcdOverlay.style.cssText = 'position:absolute;inset:0;pointer-events:none;mix-blend-mode:multiply;image-rendering:pixelated;';
    wrap.appendChild(lcdOverlay);

    function buildLcdPattern() {
      var c = document.createElement('canvas');
      c.width = 4; c.height = 4;
      var ctx = c.getContext('2d');
      var cols = [
        [255, 51, 51],
        [51, 255, 51],
        [51, 51, 255],
        [102, 102, 102],
      ];
      for (var row = 0; row < 4; row++) {
        var f = row === 3 ? 0.9 : 1.0;
        for (var col = 0; col < 4; col++) {
          var rgb = cols[col];
          ctx.fillStyle = 'rgb(' + Math.round(rgb[0] * f) + ',' + Math.round(rgb[1] * f) + ',' + Math.round(rgb[2] * f) + ')';
          ctx.fillRect(col, row, 1, 1);
        }
      }
      return c.toDataURL();
    }

    function updateLcdSize() {
      var sz = 1 / ((window.devicePixelRatio || 1) * 0.125);
      lcdOverlay.style.backgroundSize = sz + 'px ' + sz + 'px';
    }

    lcdOverlay.style.backgroundImage = 'url(' + buildLcdPattern() + ')';
    updateLcdSize();
    window.addEventListener('resize', updateLcdSize);

    /* ---- Text objects ---- */

    var GLOW = { dropShadow: true, dropShadowDistance: 0, dropShadowBlur: 6, dropShadowAlpha: 0.6 };

    var styleMain = Object.assign({ fontFamily: FONT_FAMILY, fontSize: FONT_MAIN, fill: COLOR_VERB, dropShadowColor: COLOR_VERB }, GLOW);
    var styleEllipsis = Object.assign({ fontFamily: FONT_FAMILY, fontSize: FONT_MAIN, fill: COLOR_ELLIPSIS, dropShadowColor: COLOR_ELLIPSIS }, GLOW);
    var styleMeta = Object.assign({ fontFamily: FONT_FAMILY, fontSize: FONT_META, fill: COLOR_META, dropShadowColor: COLOR_META }, GLOW);

    var glyphText = new PIXI.Text(SPINNER_FRAMES[4], styleMain);
    var verbText = new PIXI.Text('Loading', styleMain);
    var ellipsisText = new PIXI.Text('\u2026', styleEllipsis);
    var metaText = new PIXI.Text('', styleMeta);

    /* ---- Sweep highlight (3 yellow chars) ---- */
    var CHAR_DWELL_MS = 300;
    var COLOR_HIGHLIGHT = 0xffee55;
    var styleHighlight = { fontFamily: FONT_FAMILY, fontSize: FONT_MAIN, fill: COLOR_HIGHLIGHT };
    var highlightText = new PIXI.Text('', styleHighlight);

    var spinnerLine = new PIXI.Container();
    spinnerLine.addChild(glyphText, verbText, ellipsisText, highlightText);

    var metaLine = new PIXI.Container();
    metaLine.addChild(metaText);

    /* ---- Header + Input ---- */

    var COLOR_SUGGESTION = 0x555555;
    var COLOR_ACTIVE = 0xffffff;

    var inputContainer = new PIXI.Container();
    inputContainer.eventMode = 'static';
    inputContainer.cursor = 'pointer';
    var caretText = new PIXI.Text('> ', Object.assign({ fontFamily: FONT_FAMILY, fontSize: FONT_MAIN, fill: COLOR_SUGGESTION, dropShadowColor: COLOR_SUGGESTION }, GLOW));
    var inputText = new PIXI.Text('', Object.assign({ fontFamily: FONT_FAMILY, fontSize: FONT_MAIN, fill: COLOR_SUGGESTION, dropShadowColor: COLOR_SUGGESTION }, GLOW));
    inputText.x = Math.round(caretText.width);
    inputContainer.addChild(caretText, inputText);

    /* ---- Bugged placeholder ---- */

    var buggedContainer = new PIXI.Container();
    var buggedText = new PIXI.Text('BUGGED', Object.assign({ fontFamily: FONT_FAMILY, fontSize: Math.round(FONT_MAIN * 1.5), fill: 0xff0000, dropShadowColor: 0xff0000 }, GLOW));
    buggedContainer.addChild(buggedText);
    buggedContainer.visible = false;

    /* ---- Scrolling output colours ---- */

    var C_TOOL = 0x8b949e;
    var C_PATH = 0xc9d1d9;
    var C_OK = 0x4ade80;
    var C_OUT = 0x6e7681;
    var C_WARN = 0xd29922;
    var C_ERR = 0xf85149;
    var C_PROMPT = 0xbc8cff;
    var C_BORDER = 0x30363d;
    var C_LINENUM = 0x484f58;
    var C_ACCENT = 0x79c0ff;

    /* ---- Event factories ---- */

    var FILES = [
      'src/cli.ts', 'src/commands.ts', 'src/settings.ts', 'src/sets.ts',
      'src/types.ts', 'package.json', 'tsconfig.json', 'CLAUDE.md',
      'sets/freddy.json', 'biome.json', 'justfile', 'src/build-site.ts',
    ];
    var GREP_TERMS = ['loadSets', 'VerbSet', 'import.*from', 'ClaudeSettings', 'readFile', 'export'];
    var BASH_CMDS = [
      { cmd: 'bun run lint', out: ['Checked 21 files. No fixes.'] },
      { cmd: 'bun run test', out: ['\u2713 3 passed (7 tests)'] },
      { cmd: 'bunx tsc --noEmit', out: ['No errors found.'] },
      { cmd: 'bun run build', out: ['Built in 0.12s'] },
      { cmd: 'git status', out: ['2 files changed, 14 insertions'] },
      { cmd: 'git diff --stat', out: ['3 files changed, 42(+), 7(-)'] },
    ];
    var ERROR_MSGS = [
      { msg: 'Cannot find module \'./utils\'', detail: 'at resolve (node:internal/modules)' },
      { msg: 'Type \'string\' not assignable to \'number\'', detail: 'src/types.ts:14:5' },
      { msg: 'ENOENT: no such file or directory', detail: 'open \'/tmp/.cache/build\''},
    ];
    var PANEL_LINES = [
      ['Plan: update settings module', 'Step 1: read current config', 'Step 2: merge verb overrides'],
      ['Context: spinner-verbs CLI', 'Stack: TypeScript + Bun', 'Entry: src/cli.ts'],
      ['Dependencies resolved', 'bun@1.1.42', 'pixi.js@7.4.2', 'vitest@3.0.4'],
    ];

    function mkRead() {
      return { lines: [{ t: 'Read ' + pick(FILES), c: C_TOOL }] };
    }
    function mkGlob() {
      var pat = pick(['**/*.ts', 'sets/**/*.json', 'src/**/*.ts', 'templates/**/*.html']);
      return { lines: [{ t: 'Glob ' + pat + ' (' + randInt(2, 12) + ' matches)', c: C_TOOL }] };
    }
    function mkGrep() {
      return { lines: [{ t: 'Grep "' + pick(GREP_TERMS) + '" (' + randInt(1, 18) + ' matches)', c: C_TOOL }] };
    }
    function mkAssistantAction() {
      var actions = ['Read', 'Edit', 'Write', 'Glob', 'Grep'];
      var act = pick(actions);
      var file = pick(FILES);
      return { lines: [
        { t: '\u23fa ' + act + '(' + file + ')', c: C_ACCENT, col: 1 },
        { t: '\u23bf ' + randInt(8, 120) + ' lines', c: C_OUT, col: 1 },
      ], burstMs: 100 };
    }
    function mkBashCommand() {
      var b = pick(BASH_CMDS);
      var lines = [{ t: 'Bash ' + b.cmd, c: C_OUT }];
      for (var i = 0; i < b.out.length; i++) lines.push({ t: b.out[i], c: C_OK });
      return { lines: lines, burstMs: 120 };
    }
    function mkDiffHunk() {
      var file = pick(FILES);
      var startLine = randInt(1, 80);
      var lines = [
        { t: 'Edit ' + file, c: C_PATH },
        { t: '@@ -' + startLine + ',3 +' + startLine + ',4 @@', c: C_LINENUM },
      ];
      var adds = randInt(1, 3);
      var dels = randInt(0, 2);
      for (var d = 0; d < dels; d++) lines.push({ t: '- ' + pick(['const old = true;', 'return null;', '// TODO']), c: C_ERR, col: 1 });
      for (var a = 0; a < adds; a++) lines.push({ t: '+ ' + pick(['const val = parse(input);', 'return result;', 'export type Config = {};']), c: C_OK, col: 1 });
      return { lines: lines, burstMs: 80 };
    }
    function mkBoxedPanel() {
      var panel = pick(PANEL_LINES);
      var w = 34;
      var lines = [{ t: '\u256d' + repeat('\u2500', w) + '\u256e', c: C_BORDER, col: 1 }];
      for (var i = 0; i < panel.length; i++) {
        var pad = w - panel[i].length;
        lines.push({ t: '\u2502 ' + panel[i] + repeat(' ', Math.max(0, pad - 1)) + '\u2502', c: C_BORDER, col: 1 });
      }
      lines.push({ t: '\u2570' + repeat('\u2500', w) + '\u256f', c: C_BORDER, col: 1 });
      return { lines: lines, burstMs: 60 };
    }
    function mkPromptLine() {
      var cmds = ['\u276f build', '\u276f /fast', '\u276f test --watch', '\u276f lint --fix', '\u276f git push'];
      return { lines: [{ t: pick(cmds), c: C_PROMPT, col: 1 }] };
    }
    function mkErrorBlock() {
      var e = pick(ERROR_MSGS);
      return { lines: [
        { t: 'Error: ' + e.msg, c: C_ERR },
        { t: e.detail, c: C_OUT },
      ], burstMs: 100 };
    }
    function mkSearchSummary() {
      var msgs = [
        { t: '\u2713 tests passed (7/7)', c: C_OK, col: 1 },
        { t: '\u2713 lint clean', c: C_OK, col: 1 },
        { t: '\u2713 typecheck passed', c: C_OK, col: 1 },
        { t: 'Validation: 0 errors, 2 warnings', c: C_WARN },
        { t: 'warn: nl/multi-lul.json: 54 verbs', c: C_WARN },
        { t: 'Duration: ' + randInt(120, 900) + 'ms', c: C_OUT },
      ];
      return { lines: [pick(msgs)] };
    }
    function mkCompletionTagline() {
      var msgs = [
        { t: 'Cooked for ' + randInt(8, 45) + 's', c: C_OUT },
        { t: '\u2193 ' + randInt(800, 4200) + ' tokens used', c: C_OUT, col: 1 },
        { t: 'Done in ' + randInt(2, 18) + 's', c: C_OUT },
      ];
      return { lines: [pick(msgs)] };
    }
    function mkModeToggle() {
      return { lines: [
        { t: '/fast', c: C_PROMPT, col: 1 },
        { t: 'Fast mode enabled', c: C_OK },
      ], burstMs: 150 };
    }

    var EVENT_TABLE = [
      { fn: mkRead, w: 20 },
      { fn: mkGlob, w: 6 },
      { fn: mkGrep, w: 6 },
      { fn: mkAssistantAction, w: 12 },
      { fn: mkBashCommand, w: 8 },
      { fn: mkDiffHunk, w: 5 },
      { fn: mkBoxedPanel, w: 3 },
      { fn: mkPromptLine, w: 4 },
      { fn: mkErrorBlock, w: 2 },
      { fn: mkSearchSummary, w: 6 },
      { fn: mkCompletionTagline, w: 3 },
      { fn: mkModeToggle, w: 2 },
    ];
    var TOTAL_WEIGHT = 0;
    for (var i = 0; i < EVENT_TABLE.length; i++) TOTAL_WEIGHT += EVENT_TABLE[i].w;

    function pickEvent() {
      var r = Math.random() * TOTAL_WEIGHT;
      var cum = 0;
      for (var i = 0; i < EVENT_TABLE.length; i++) {
        cum += EVENT_TABLE[i].w;
        if (r < cum) return EVENT_TABLE[i].fn();
      }
      return EVENT_TABLE[EVENT_TABLE.length - 1].fn();
    }

    /* ---- Line buffer ---- */

    var lineBuffer = [];
    var currentBurstMs = 0;
    var linesLeftInBurst = 0;

    var BLANK = { t: ' ', c: BG_COLOR };

    function feedBuffer() {
      if (lineBuffer.length > 0) return;
      var evt = pickEvent();
      lineBuffer = evt.lines.slice();
      lineBuffer.push(BLANK);
      currentBurstMs = evt.burstMs || 0;
      linesLeftInBurst = lineBuffer.length;
    }

    function nextLine() {
      feedBuffer();
      linesLeftInBurst--;
      return lineBuffer.shift();
    }

    var scrollContainer = new PIXI.Container();
    var scrollItems = [];

    /* ---- Bottom chrome ---- */

    var C_RULE = 0x30363d;
    var C_DIM = 0x6e7681;
    var styleRule = Object.assign({ fontFamily: FONT_FAMILY, fontSize: FONT_MAIN, fill: C_RULE, dropShadowColor: C_RULE }, GLOW);
    var styleDim = Object.assign({ fontFamily: FONT_FAMILY, fontSize: FONT_MAIN, fill: C_DIM, dropShadowColor: C_DIM }, GLOW);
    var stylePrompt = Object.assign({ fontFamily: FONT_FAMILY, fontSize: FONT_MAIN, fill: C_PROMPT, dropShadowColor: C_PROMPT }, GLOW);

    var ruleTop = new PIXI.Text('', styleRule);
    var promptText = new PIXI.Text('\u276f', stylePrompt);
    var ruleBottom = new PIXI.Text('', styleRule);
    var statusText = new PIXI.Text('', styleDim);
    var C_PERMS = 0xd29922;
    var stylePerms = Object.assign({ fontFamily: FONT_FAMILY, fontSize: FONT_MAIN, fill: C_PERMS, dropShadowColor: C_PERMS }, GLOW);
    var permsText = new PIXI.Text('', stylePerms);
    var infoText = new PIXI.Text('', styleDim);

    var bottomChrome = new PIXI.Container();
    bottomChrome.addChild(ruleTop, promptText, ruleBottom, statusText, permsText, infoText);

    app.stage.addChild(scrollContainer, spinnerLine, metaLine, bottomChrome, inputContainer, buggedContainer);

    /* ---- Bloom ---- */
    if (PIXI.filters && PIXI.filters.AdvancedBloomFilter) {
      app.stage.filters = [new PIXI.filters.AdvancedBloomFilter({
        threshold: 0.3,
        bloomScale: 0.6,
        brightness: 1.1,
        blur: 4,
        quality: 2,
      })];
    }

    /* ---- Layout ---- */

    var chMetric = new PIXI.Text('M', { fontFamily: FONT_FAMILY, fontSize: FONT_MAIN });
    var chW = chMetric.width;
    chMetric.destroy();
    var prevRuleCols = 0;

    function layout() {
      var col3 = Math.round(3 * chW);
      verbText.x = col3;
      ellipsisText.x = verbText.x + verbText.width;

      var leftX = Math.round(chW * 2);
      spinnerLine.x = leftX;
      spinnerLine.y = Math.round(app.screen.height / 2 - glyphText.height);

      metaLine.x = leftX + col3;
      metaLine.y = Math.round(spinnerLine.y + glyphText.height + 8);

      scrollContainer.x = leftX;

      // bottom chrome
      var lh = glyphText.height;
      var pad = Math.round(lh * 0.3);
      var ruleCols = Math.max(1, Math.floor(app.screen.width / chW) - 2);
      if (ruleCols !== prevRuleCols) {
        var rule = repeat('\u2500', ruleCols);
        ruleTop.text = rule;
        ruleBottom.text = rule;
        prevRuleCols = ruleCols;
      }

      var bottomY = metaLine.y + lh + pad;
      var ch1 = Math.round(chW);
      bottomChrome.x = leftX;

      ruleTop.x = ch1;
      ruleTop.y = bottomY;
      promptText.x = ch1;
      promptText.y = bottomY + lh + pad;
      ruleBottom.x = ch1;
      ruleBottom.y = bottomY + lh * 2 + pad * 2;
      statusText.x = ch1;
      statusText.y = bottomY + lh * 3 + pad * 3;
      permsText.x = ch1;
      permsText.y = statusText.y + lh + pad;
      infoText.x = ch1;
      infoText.y = permsText.y + lh + pad;

      /* visibility per state */
      var inIdle = machine.current === S.IDLE;
      var inTerminal = !inIdle && machine.current !== S.BUGGED;
      inputContainer.visible = false;
      scrollContainer.visible = inIdle || inTerminal;
      spinnerLine.visible = inTerminal;
      metaLine.visible = machine.current === S.DEMO;
      bottomChrome.visible = inIdle || inTerminal;
      buggedContainer.visible = machine.current === S.BUGGED;

      if (inIdle) {
        /* vertically centre header + prompt group */
        var headerH = scrollItems.length * Math.round(glyphText.height * 1.25);
        var chromeH = lh * 3 + pad * 3;
        var totalH = headerH + chromeH;
        var topY = Math.round((app.screen.height - totalH) / 2);
        for (var si = 0; si < scrollItems.length; si++) {
          scrollItems[si].y = topY + si * Math.round(glyphText.height * 1.25);
        }
        /* anchor bottom chrome just below header */
        var chromeBotY = topY + headerH + pad;
        ruleTop.y = chromeBotY;
        promptText.y = chromeBotY + lh + pad;
        ruleBottom.y = chromeBotY + lh * 2 + pad * 2;
        statusText.visible = false;
        permsText.visible = false;
        infoText.visible = false;
      } else {
        if (inTerminal) layoutScrollItems();
        statusText.visible = true;
        permsText.visible = true;
        infoText.visible = true;
      }

      buggedContainer.x = leftX;
      buggedContainer.y = Math.round((app.screen.height - buggedText.height) / 2);
    }

    function layoutScrollItems() {
      var lh = Math.round(glyphText.height * 1.25);
      var gap = Math.round(lh * 0.6);
      for (var i = 0; i < scrollItems.length; i++) {
        scrollItems[i].y = spinnerLine.y - gap - (scrollItems.length - i) * lh;
      }
      while (scrollItems.length > 0 && scrollItems[0].y + lh < 0) {
        scrollContainer.removeChild(scrollItems[0]);
        scrollItems[0].destroy();
        scrollItems.shift();
      }
    }

    function addScrollLine() {
      var line = nextLine();
      var txt = new PIXI.Text(line.t, Object.assign({ fontFamily: FONT_FAMILY, fontSize: FONT_MAIN, fill: line.c, dropShadowColor: line.c }, GLOW));
      txt.x = Math.round((line.col || 3) * chW);
      scrollContainer.addChild(txt);
      scrollItems.push(txt);
      layoutScrollItems();
    }

    /* ---- State management ---- */

    function updateSuggestion() {
      var text = '';
      if (machine.current === S.IDLE) {
        text = defaultSet ? 'Show me some verbs of ' + defaultSet.name : 'No sets available';
        promptText.text = '\u276f ' + text;
        promptText.style.fill = COLOR_SUGGESTION;
        promptText.style.dropShadowColor = COLOR_SUGGESTION;
        return;
      }
      var hint = '';
      if (machine.current === S.BROWSING) {
        if (machine.skipCount >= 4 && idiotSet) {
          text = 'Show me some verbs of an idt';
        } else {
          var bs = localeSets[machine.browseIndex % localeSets.length];
          text = bs ? 'Show me some verbs of ' + bs.name : '';
        }
        hint = '\u2191\u2193 browse \u00b7 enter to demo';
      } else if (machine.current === S.POST_DEMO) {
        text = POST_SUGGESTIONS[machine.postIndex].text;
        hint = '\u2191\u2193 browse \u00b7 enter to select';
      }
      promptText.text = '\u276f ' + text + '   ' + hint;
      promptText.style.fill = COLOR_ACTIVE;
      promptText.style.dropShadowColor = COLOR_ACTIVE;
      verbText.text = '';
      ellipsisText.visible = false;
      highlightText.visible = false;
    }

    function startDemo(set) {
      if (!set) return;
      machine.activeSet = set;
      var sv = set.verbs ? set.verbs.slice() : [];
      if (set === idiotSet) {
        for (var di = 0; di < sv.length; di++) sv[di] = sv[di] + ' like an idiot';
      }
      verbs = shuffle(sv);
      if (verbs.length === 0) verbs = ['Thinking', 'Processing'];
      verbIdx = 0;
      verbText.text = verbs[0];
      verbText.style.fill = COLOR_VERB;
      verbText.style.dropShadowColor = COLOR_VERB;
      ellipsisText.visible = true;
      promptText.text = '\u276f';
      promptText.style.fill = C_PROMPT;
      promptText.style.dropShadowColor = C_PROMPT;
      tokenCount = 0;
      startTime = Date.now();
      lastFrameTime = 0;
      lastVerbTime = 0;
      lastTokenTime = 0;
      lastScrollTime = 0;
      for (var ci = scrollItems.length - 1; ci >= 0; ci--) {
        scrollContainer.removeChild(scrollItems[ci]);
        scrollItems[ci].destroy();
      }
      scrollItems = [];
      machine.demoTimer = setTimeout(function () { dispatch('DEMO_TIMEOUT'); }, DEMO_TIMEOUT_MS);
    }

    function stopDemo() {
      if (machine.demoTimer) { clearTimeout(machine.demoTimer); machine.demoTimer = null; }
    }

    function enterState(state) {
      exitState(machine.current);
      machine.previous = machine.current;
      machine.current = state;
      if (state === S.POST_DEMO) machine.postIndex = 0;
      if (state === S.IDLE || state === S.BROWSING || state === S.POST_DEMO) updateSuggestion();
      if (state === S.DEMO) startDemo(machine.activeSet);
    }

    function exitState(state) {
      if (state === S.DEMO) stopDemo();
    }

    function dispatch(event) {
      var m = machine;
      switch (m.current) {
        case S.IDLE:
          if (event === 'ENTER' && defaultSet) { m.activeSet = defaultSet; enterState(S.DEMO); }
          else if (event === 'ARROW_DOWN' && localeSets.length > 0) { m.browseIndex = 1 % localeSets.length; m.skipCount = 0; enterState(S.BROWSING); }
          else if (event === 'SHIFT_TAB') enterState(S.BUGGED);
          break;
        case S.BROWSING:
          if (event === 'ENTER') {
            m.activeSet = (m.skipCount >= 4 && idiotSet) ? idiotSet : localeSets[m.browseIndex % localeSets.length];
            enterState(S.DEMO);
          } else if (event === 'ARROW_DOWN') {
            m.skipCount++;
            if (!(m.skipCount >= 4 && idiotSet)) m.browseIndex = (m.browseIndex + 1) % localeSets.length;
            updateSuggestion();
          } else if (event === 'ARROW_UP') {
            if (m.skipCount >= 4 && idiotSet) { m.skipCount = 3; updateSuggestion(); }
            else if (m.browseIndex - 1 <= 0) enterState(S.IDLE);
            else { m.browseIndex--; m.skipCount = Math.max(0, m.skipCount - 1); updateSuggestion(); }
          } else if (event === 'SHIFT_TAB') enterState(S.BUGGED);
          break;
        case S.DEMO:
          if (event === 'ESC' || event === 'DEMO_TIMEOUT') enterState(S.POST_DEMO);
          else if (event === 'SHIFT_TAB') enterState(S.BUGGED);
          break;
        case S.POST_DEMO:
          if (event === 'ENTER') {
            var act = POST_SUGGESTIONS[m.postIndex].action;
            if (act === 'copy' && m.activeSet) navigator.clipboard.writeText('bunx spinner-verbs install ' + m.activeSet.name);
            else if (act === 'marketplace') window.location.href = 'marketplace.html';
          } else if (event === 'ARROW_DOWN') { m.postIndex = (m.postIndex + 1) % POST_SUGGESTIONS.length; updateSuggestion(); }
          else if (event === 'ARROW_UP') { m.postIndex = (m.postIndex - 1 + POST_SUGGESTIONS.length) % POST_SUGGESTIONS.length; updateSuggestion(); }
          else if (event === 'SHIFT_TAB') enterState(S.BUGGED);
          break;
        case S.BUGGED:
          if (event === 'ESC') enterState(m.previous);
          break;
      }
    }

    /* ---- State ---- */

    var verbs = [];
    var verbIdx = 0;
    var spinnerTick = 0;
    var tokenCount = 0;
    var startTime = Date.now();
    var lastFrameTime = 0;
    var lastVerbTime = 0;
    var lastTokenTime = 0;
    var lastScrollTime = 0;

    /* ---- Animation loop ---- */

    app.ticker.add(function () {
      var now = Date.now();

      if (now - lastFrameTime >= FRAME_MS) {
        spinnerTick++;
        var fi = SPINNER_TIMELINE[spinnerTick % SPINNER_TIMELINE.length];
        glyphText.text = SPINNER_FRAMES[fi];
        lastFrameTime = now;
      }

      /* scroll + bottom chrome: all terminal states */
      if (machine.current !== S.IDLE && machine.current !== S.BUGGED) {
        var scrollDelay = (currentBurstMs > 0 && linesLeftInBurst > 0) ? currentBurstMs : SCROLL_MS;
        if (now - lastScrollTime >= scrollDelay) {
          addScrollLine();
          lastScrollTime = now;
        }
        statusText.text = '\u2026/_management\u2026/spinner-verbs\u2026/site   main *5';
        permsText.text = '\u23f5\u23f5 bypass permissions on (shift+tab to cycle) \u00b7 5 files +322 -66';
        var h = Math.floor((now - startTime) / 3600000);
        var m = Math.floor(((now - startTime) % 3600000) / 60000);
        var timeStr = String(h).padStart(2, '0') + ':' + String(m).padStart(2, '0');
        infoText.text = timeStr + ' | tip: /git:commit';
      }

      /* verb rotation + highlight: DEMO only */
      if (machine.current === S.DEMO) {
        if (verbs.length > 0 && now - lastVerbTime >= VERB_MS) {
          verbIdx = (verbIdx + 1) % verbs.length;
          verbText.text = verbs[verbIdx];
          lastVerbTime = now;
        }

        if (now - lastTokenTime >= 1000) {
          tokenCount += TOKEN_RATE + Math.floor(Math.random() * 20 - 10);
          lastTokenTime = now;
        }

        var verb = verbText.text;
        var totalSteps = verb.length + 2;
        var cycleMs = totalSteps * CHAR_DWELL_MS;
        if (verb.length > 0) {
          var step = Math.floor((now % cycleMs) / CHAR_DWELL_MS) - 2;
          var start = Math.max(0, step);
          var end = Math.min(verb.length, step + 3);
          highlightText.text = verb.substring(start, end);
          highlightText.x = verbText.x + start * chW;
          highlightText.visible = end > start;
        }

        var elapsed = fmtElapsed(now - startTime);
        metaText.text = '(esc to interrupt \u00b7 ' + elapsed + ' \u00b7 \u2193 ' + tokenCount + ' tokens \u00b7 thinking)';
      }

      layout();
    });

    /* ---- Keyboard ---- */

    document.addEventListener('keydown', function (e) {
      if (e.key === 'Enter') { e.preventDefault(); dispatch('ENTER'); }
      else if (e.key === 'ArrowDown') { e.preventDefault(); dispatch('ARROW_DOWN'); }
      else if (e.key === 'ArrowUp') { e.preventDefault(); dispatch('ARROW_UP'); }
      else if (e.key === 'Escape') { dispatch('ESC'); }
      else if (e.key === 'Tab' && e.shiftKey) { e.preventDefault(); dispatch('SHIFT_TAB'); }
    });

    inputContainer.on('pointertap', function () { dispatch('ENTER'); });
    promptText.eventMode = 'static';
    promptText.cursor = 'pointer';
    promptText.on('pointertap', function () {
      if (machine.current === S.IDLE) dispatch('ENTER');
    });

    /* ---- Init ---- */

    var headerRowData = buildHeaderRows(80);
    for (var hi = 0; hi < headerRowData.length; hi++) {
      var hr = headerRowData[hi];
      var rowContainer = new PIXI.Container();
      rowContainer.x = Math.round(chW);
      var xOff = 0;
      for (var pi = 0; pi < hr.parts.length; pi++) {
        var part = hr.parts[pi];
        var pt = new PIXI.Text(part.text, { fontFamily: FONT_FAMILY, fontSize: FONT_MAIN, fill: part.color });
        pt.x = xOff;
        xOff += pt.width;
        rowContainer.addChild(pt);
      }
      scrollContainer.addChild(rowContainer);
      scrollItems.push(rowContainer);
    }
    enterState(S.IDLE);
    layout();
  })();
  </script>
</body>
</html>
